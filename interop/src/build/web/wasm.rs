use crate::util::RunningProcess;
use color_eyre::eyre::Result;
use glob::glob;
use std::net::SocketAddr;
use std::path::{Path, PathBuf};

/// `Cargo.toml` + all rust sources (including `build.rs`)
fn rust_source_files(crate_path: &str) -> impl Iterator<Item = PathBuf> {
    [format!("{crate_path}/Cargo.toml"), format!("{crate_path}/build.rs")]
        .into_iter()
        .map(Into::into)
        .chain(
            glob(&format!("{crate_path}/src/**/*.rs"))
                .expect("no syntax errors in glob string")
                .filter_map(Result::ok),
        )
}

/// `true` if any source in sources has an mtime >= the target's, or if enough IO errors happened that
/// the target or max source mtime could not be read.
fn should_rebuild(target: impl AsRef<Path>, sources: impl IntoIterator<Item = impl AsRef<Path>>) -> bool {
    let target_mtime = std::fs::metadata(target).and_then(|metadata| metadata.modified()).ok();
    let last_source_mtime = sources
        .into_iter()
        .filter_map(|path| std::fs::metadata(path).ok()?.modified().ok())
        .max();
    // if we couldn't read or find any of the input files, we need a rebuild
    last_source_mtime
        .zip(target_mtime)
        .map(|(source, target)| source >= target)
        .unwrap_or(true)
}

pub(crate) async fn build_wasm(wasm_deploy_path: PathBuf) -> Result<()> {
    use tokio::process::Command;

    let cwd = std::env::current_dir()?;

    if cfg!(feature = "proteus") {
        let spinner = RunningProcess::new("Building Cryptobox ESM bundle...", false);

        Command::new("bun")
            .args(["install"])
            .current_dir(cwd.join("interop/src/build/web/cryptobox-esm"))
            .stdout(std::process::Stdio::null())
            .stderr(std::process::Stdio::null())
            .status()
            .await?;

        Command::new("bun")
            .args(["run", "build"])
            .current_dir(cwd.join("interop/src/build/web/cryptobox-esm"))
            .stdout(std::process::Stdio::null())
            .stderr(std::process::Stdio::null())
            .status()
            .await?;

        spinner.success("Cryptobox ESM bundle [OK]");
    }

    let spinner = RunningProcess::new("Determining whether to build wasm...", false);

    let wasm_target = "crypto-ffi/bindings/js/src/autogenerated/core-crypto-ffi_bg.wasm";
    let wasm_sources = ["crypto", "crypto-ffi", "mls-provider", "keystore", "crypto-macros"]
        .into_iter()
        .flat_map(rust_source_files)
        .chain(["Cargo.lock"].into_iter().map(Into::into))
        .chain(glob(".cargo/*").expect("well-formed glob").filter_map(Result::ok));

    let need_to_build_wasm = should_rebuild(wasm_target, wasm_sources);
    spinner.success("WASM build check [OK]");

    if need_to_build_wasm {
        let spinner = RunningProcess::new("Building WASM bundle...", false);

        Command::new("cargo")
            .args(["make", "wasm-build", "--dev"])
            .current_dir(cwd.join("crypto-ffi"))
            .stdout(std::process::Stdio::null())
            .stderr(std::process::Stdio::null())
            .status()
            .await?;

        spinner.success("Building WASM [OK]");
    }

    let need_to_build_bun = need_to_build_wasm || {
        let spinner = RunningProcess::new("Determining whether to build JS...", false);

        let ts_target = "crypto-ffi/bindings/js/src/corecrypto.js";
        let ts_sources = glob("crypto-ffi/bindings/js/**/*.ts")?.filter_map(Result::ok);

        let outdated_ts = should_rebuild(ts_target, ts_sources);
        spinner.success("JS build check [OK]");
        outdated_ts
    };

    if need_to_build_bun {
        let spinner = RunningProcess::new("Bundling TS sources...", false);

        Command::new("bun")
            .args(["run", "build"])
            .current_dir(cwd.join("crypto-ffi/bindings/js"))
            .stdout(std::process::Stdio::null())
            .stderr(std::process::Stdio::null())
            .status()
            .await?;

        spinner.success("Bundling TS [OK]");
    }

    let spinner = RunningProcess::new("Copying data into WASM bundle...", false);

    std::fs::copy(
        cwd.join("crypto-ffi/bindings/js/test/wdio/index.html"),
        wasm_deploy_path.join("index.html"),
    )?;

    std::fs::copy(
        cwd.join("crypto-ffi/bindings/js/src/corecrypto.js"),
        wasm_deploy_path.join("corecrypto.js"),
    )?;

    std::fs::copy(
        cwd.join("crypto-ffi/bindings/js/src/corecrypto.d.ts"),
        wasm_deploy_path.join("corecrypto.d.ts"),
    )?;

    std::fs::create_dir(wasm_deploy_path.join("autogenerated"))?;
    std::fs::copy(
        cwd.join("crypto-ffi/bindings/js/src/autogenerated/core-crypto-ffi_bg.wasm"),
        wasm_deploy_path.join("autogenerated/core-crypto-ffi_bg.wasm"),
    )?;

    spinner.success("WASM bundle [OK]");
    Ok(())
}

pub(crate) fn bind_http_server(wasm_deploy_path: PathBuf) -> (SocketAddr, impl Future<Output = ()> + 'static) {
    use warp::Filter as _;
    let warp_filter_cc = warp::path("core-crypto").and(warp::fs::dir(wasm_deploy_path));
    let warp_filter_cbox =
        warp::path("cryptobox").and(warp::fs::dir("interop/src/build/web/cryptobox-esm/dist".to_string()));

    warp::serve(warp_filter_cc.or(warp_filter_cbox).boxed()).bind_ephemeral(([0, 0, 0, 0], 0))
}
