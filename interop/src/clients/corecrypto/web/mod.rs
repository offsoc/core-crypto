use crate::{
    CIPHERSUITE_IN_USE,
    clients::{EmulatedClient, EmulatedClientProtocol, EmulatedClientType, EmulatedMlsClient},
};
use color_eyre::eyre::{Result, eyre};
use core_crypto::prelude::{KeyPackage, KeyPackageIn};
use std::cell::Cell;
use std::net::SocketAddr;
use tls_codec::Deserialize;

#[derive(Debug)]
pub(crate) struct CoreCryptoWebClient {
    browser: fantoccini::Client,
    client_id: Vec<u8>,
    #[cfg(feature = "proteus")]
    prekey_last_id: Cell<u16>,
}

impl CoreCryptoWebClient {
    pub(crate) async fn new(driver_addr: &SocketAddr, server: &SocketAddr) -> Result<Self> {
        let client_id = uuid::Uuid::new_v4();
        let client_id_str = client_id.as_hyphenated().to_string();
        let ciphersuite = CIPHERSUITE_IN_USE as u16;
        let client_config = serde_json::json!({
            "databaseName": format!("db-{client_id_str}"),
            "ciphersuites": [ciphersuite],
            "clientId": client_id_str
        });

        let browser = crate::build::web::webdriver::setup_browser(driver_addr, server, "core-crypto").await?;
        browser.execute(r#"
    const { CoreCrypto, Ciphersuite, Ciphersuites, ClientId, CredentialType, DatabaseKey, initWasmModule, ciphersuiteFromU16 } = await import("./corecrypto.js");
    await initWasmModule("autogenerated/");

    let [clientConfig] = arguments;
    clientConfig.clientId = new ClientId(new TextEncoder().encode(clientConfig.clientId));
    clientConfig.ciphersuites = clientConfig.ciphersuites.map((n) => ciphersuiteFromU16(n));

    const key = new Uint8Array(32);
    window.crypto.getRandomValues(key);
    clientConfig.key = new DatabaseKey(key);

    window.CoreCrypto = CoreCrypto;
    window.cc = await window.CoreCrypto.init(clientConfig);
    window.ciphersuite = clientConfig.ciphersuites[0];
    window.credentialType = CredentialType.Basic;

    window.deliveryService = {
        async sendCommitBundle() {
            return "success";
        },
        async sendMessage() {
            return "success";
        },
        async prepareForTransport(secret) {
            return new MlsTransportData(secret.data)
        }
    };

    await window.cc.provideTransport(window.deliveryService);
    "#, vec![client_config]).await?;

        Ok(Self {
            browser,
            client_id: client_id.into_bytes().into(),
            #[cfg(feature = "proteus")]
            prekey_last_id: Cell::new(0),
        })
    }
}

#[async_trait::async_trait(?Send)]
impl EmulatedClient for CoreCryptoWebClient {
    fn client_name(&self) -> &str {
        "CoreCrypto::wasm"
    }

    fn client_type(&self) -> EmulatedClientType {
        EmulatedClientType::Web
    }

    fn client_id(&self) -> &[u8] {
        self.client_id.as_slice()
    }

    fn client_protocol(&self) -> EmulatedClientProtocol {
        EmulatedClientProtocol::MLS | EmulatedClientProtocol::PROTEUS
    }

    async fn wipe(&mut self) -> Result<()> {
        let client_id = uuid::Uuid::from_slice(self.client_id.as_slice())?;
        let client_id_str = client_id.as_hyphenated().to_string();
        let database_name = format!("db-{client_id_str}");
        let _ = self
            .browser
            .execute_async(
                r#"
    const [databaseName, callback] = arguments;
    await window.cc.close();
    const result = window.indexedDB.deleteDatabase(databaseName);
    result.onsuccess = callback;
    result.onfailure = callback;
    "#,
                vec![serde_json::json!(database_name)],
            )
            .await?;

        Ok(())
    }
}

#[async_trait::async_trait(?Send)]
impl EmulatedMlsClient for CoreCryptoWebClient {
    async fn get_keypackage(&self) -> Result<Vec<u8>> {
        let start = std::time::Instant::now();
        let kp_raw = self
            .browser
            .execute(
                r#"
    const [kp] = await window.cc.transaction((ctx) =>
        ctx.clientKeypackages(window.ciphersuite, window.credentialType, 1)
    );
    return kp;
    "#,
                vec![],
            )
            .await?;
        let kp_raw = serde_json::from_value::<Vec<u8>>(kp_raw)?;

        let kp: KeyPackage = KeyPackageIn::tls_deserialize(&mut kp_raw.as_slice())?.into();

        log::info!(
            "KP Init Key [took {}ms]: Client {} [{}] - {}",
            start.elapsed().as_millis(),
            self.client_name(),
            hex::encode(&self.client_id),
            hex::encode(kp.hpke_init_key()),
        );

        Ok(kp_raw)
    }

    async fn add_client(&self, conversation_id: &[u8], kp: &[u8]) -> Result<()> {
        self.browser
            .execute(
                r#"
    const { ConversationId } = await import("./corecrypto.js");
    const [cId, kp] = arguments;
    const conversationId = new ConversationId(Uint8Array.from(Object.values(cId)));
    const keyPackage = Uint8Array.from(Object.values(kp));

    if (!window.cc.conversationExists(conversationId)) {
        await window.cc.transaction((ctx) =>
            ctx.createConversation(conversationId, window.credentialType, { ciphersuite: window.ciphersuite })
        );
    }
    await window.cc.transaction((ctx) =>
        ctx.addClientsToConversation(conversationId, [keyPackage]));
    "#,
                vec![conversation_id.into(), kp.into()],
            )
            .await?;
        Ok(())
    }

    async fn kick_client(&self, conversation_id: &[u8], client_id: &[u8]) -> Result<()> {
        self.browser
            .execute(
                r#"
    const { ConversationId, ClientId } = await import("./corecrypto.js");
    const [cId, clId] = arguments;
    const conversationId = new ConversationId(Uint8Array.from(Object.values(cId)));
    const clientId = new ClientId(Uint8Array.from(Object.values(clId)));

    await window.cc.transaction((ctx) =>
        ctx.removeClientsFromConversation(conversationId, [clientId]));
    "#,
                vec![conversation_id.into(), client_id.into()],
            )
            .await?;
        Ok(())
    }

    async fn process_welcome(&self, welcome: &[u8]) -> Result<Vec<u8>> {
        let value = self
            .browser
            .execute(
                r#"
    const { Welcome } = await import("./corecrypto.js");
    const [welcome] = arguments;
    const welcomeMessage = new Welcome(Uint8Array.from(Object.values(welcome)));

    const { id } = await window.cc.transaction((ctx) =>
        ctx.processWelcomeMessage(welcomeMessage));
    return id.copyBytes();
    "#,
                vec![welcome.into()],
            )
            .await?;
        serde_json::from_value(value).map_err(Into::into)
    }

    async fn encrypt_message(&self, conversation_id: &[u8], message: &[u8]) -> Result<Vec<u8>> {
        let value = self
            .browser
            .execute(
                r#"
    const { ConversationId } = await import("./corecrypto.js");
    const [cId, cleartext] = arguments;
    const conversationId = new ConversationId(Uint8Array.from(Object.values(cId)));
    const message = Uint8Array.from(Object.values(cleartext));

    return await window.cc.transaction((ctx) =>
        ctx.encryptMessage(conversationId, message));
    "#,
                vec![conversation_id.into(), message.into()],
            )
            .await?;
        serde_json::from_value(value).map_err(Into::into)
    }

    async fn decrypt_message(&self, conversation_id: &[u8], message: &[u8]) -> Result<Option<Vec<u8>>> {
        let value = self
            .browser
            .execute(
                r#"
    const { ConversationId } = await import("./corecrypto.js");
    const [cId, encMessage] = arguments;
    const conversationId = new ConversationId(Uint8Array.from(Object.values(cId)));
    const encryptedMessage = Uint8Array.from(Object.values(encMessage));

    const { message } = await window.cc.transaction((ctx) =>
        ctx.decryptMessage(conversationId, encryptedMessage)
    );
    return message;
    "#,
                vec![conversation_id.into(), message.into()],
            )
            .await?;
        serde_json::from_value(value).map_err(Into::into)
    }
}

#[cfg(feature = "proteus")]
#[async_trait::async_trait(?Send)]
impl crate::clients::EmulatedProteusClient for CoreCryptoWebClient {
    async fn init(&mut self) -> Result<()> {
        self.browser
            .execute(
                r#"
window.cc.transaction((ctx) =>
    ctx.proteusInit()
);"#,
                vec![],
            )
            .await?;

        Ok(())
    }

    async fn get_prekey(&self) -> Result<Vec<u8>> {
        let prekey_last_id = self.prekey_last_id.get() + 1;
        self.prekey_last_id.replace(prekey_last_id);
        let prekey = self
            .browser
            .execute(
                r#"
const [prekeyId] = arguments;
const prekey = await window.cc.transaction((ctx) =>
    ctx.proteusNewPrekey(prekeyId)
);
return prekey;"#,
                vec![prekey_last_id.into()],
            )
            .await
            .and_then(|value| Ok(serde_json::from_value(value)?))?;

        Ok(prekey)
    }

    async fn session_from_prekey(&self, session_id: &str, prekey: &[u8]) -> Result<()> {
        self.browser
            .execute(
                r#"
const [sessionId, prekey] = arguments;
const prekeyBuffer = Uint8Array.from(Object.values(prekey));
await window.cc.transaction((ctx) =>
    ctx.proteusSessionFromPrekey(sessionId, prekeyBuffer)
);"#,
                vec![session_id.into(), prekey.into()],
            )
            .await?;
        Ok(())
    }

    async fn session_from_message(&self, session_id: &str, message: &[u8]) -> Result<Vec<u8>> {
        let cleartext = self
            .browser
            .execute(
                r#"
const [sessionId, message] = arguments;
const messageBuffer = Uint8Array.from(Object.values(message));
const plaintext = await window.cc.transaction((ctx) =>
    ctx.proteusSessionFromMessage(sessionId, messageBuffer)
);
return plaintext;"#,
                vec![session_id.into(), message.into()],
            )
            .await
            .and_then(|value| Ok(serde_json::from_value(value)?))?;

        Ok(cleartext)
    }
    async fn encrypt(&self, session_id: &str, plaintext: &[u8]) -> Result<Vec<u8>> {
        let ciphertext = self
            .browser
            .execute(
                r#"
const [sessionId, plaintext] = arguments;
const plaintextBuffer = Uint8Array.from(Object.values(plaintext));
const ciphertext = await window.cc.transaction((ctx) =>
    ctx.proteusEncrypt(sessionId, plaintextBuffer)
);
return ciphertext;"#,
                vec![session_id.into(), plaintext.into()],
            )
            .await
            .and_then(|value| Ok(serde_json::from_value(value)?))?;

        Ok(ciphertext)
    }

    async fn decrypt(&self, session_id: &str, ciphertext: &[u8]) -> Result<Vec<u8>> {
        let cleartext = self
            .browser
            .execute(
                r#"
const [sessionId, ciphertext] = arguments;
const ciphertextBuffer = Uint8Array.from(Object.values(ciphertext));
const plaintext = await window.cc.transaction((ctx) =>
    ctx.proteusDecrypt(sessionId, ciphertextBuffer)
);
return plaintext;"#,
                vec![session_id.into(), ciphertext.into()],
            )
            .await
            .and_then(|value| Ok(serde_json::from_value(value)?))?;

        Ok(cleartext)
    }

    async fn fingerprint(&self) -> Result<String> {
        self.browser
            .execute("return window.cc.proteusFingerprint();", vec![])
            .await?
            .as_str()
            .map(Into::into)
            .ok_or(eyre!("no proteus fingerprint returned"))
    }
}
